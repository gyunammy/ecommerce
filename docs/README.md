계층별 역할
    - presentation (controller) - HTTP 요청을 받고 검증하며, 응답을 반환하고, 비즈니스 로직을 호출한다.
    - application (useCase, service) - 요청의 흐름을 담으며 트랜잭션 관리나 권한체크를 한다. 
    - domain (Entity) - 핵심 비즈니스 규칙을 담은 객체
    - infrastructure - 외부 API 등 외부 시스템과의 I/O 처리, 및 기술적인 의존성 처리를 한다.

- 동시성 제어 분석 

1. 쿠폰 발급

   서비스단에서 ConcurrentHashMap을 사용해서 발급 받고자 하는 couponId를 통해 Lock을 발급받아 동시성 제어 하도록 처리함

2. 주문 생성
    
    처음에는 OrderItem 도메인의 ProductId 값을 사용해 쿠폰발급과 같이 Lock을 발급받아 동시성 제어를 해볼까 했었는데 
    OrderItem 수만큼 Lock을 관리하는게 금주내에 구현하지 못할 것 같아 진입 시 synchronized 키워드를 사용해서 동시성 제어를 함

두 방식의 차이점
   
  synchronized 는 jvm이 제공하는 기본 동기화 키워드로 메서드 또는 코드 블록에 선언하여 Lock을 자동으로 관리한다. 사용법이
  매우 간단하며 가독성이 높다는 점과 Lock 획득/해제가 자동처리되어 따로 코드를 작성하지 않아도 된다는 장점이 있는반면
  lock을 얻는 순서가 정해져 있지 않아 특정 요청이 오래 대기상태에 머물러 있을 수 있다는 점과 대기상태에 머물러 있는 스레드를
  제어할 수 없다는 단점이 있다.
  
  lock은 보다 세밀한 동기화 제어가 필요한 경우 사용되는 동시성 도구이며 Lock 획득과 해제를 코드로 직접 제어하게 된다.
  synchronized와는 달리 먼저 대기한 스레드가 먼저 lock을 발급받도록 순서가 정해져있기 때문에 무한정 대기상태에 빠질 일이
  적고, 대기상태에 머물러 있는 스레드를 interrupt로 제어하거나 대기 시간을 타임아웃으로 설정하여 일정시간이 지나면 대기상태에서
  빠져나오도록 설정할 수 있다는 장점이 있다. 하지만 직접 Lock에 대한 획득과 해제에 대한 코드를 작성 해줘야 한다는 점과 해제를 
  누락할 경우 무한정 대기상태에 빠지는 데드락의 위험이 있다는 단점이 있다.